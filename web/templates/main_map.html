<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ—ºï¸ The Dying Lands - Interactive Map</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="/static/fonts.css" rel="stylesheet">
    <style>
    :root {
        --mork-black: #000000;
        --mork-cyan: #00FFFF;
        --mork-yellow: #FFFF00;
        --mork-green: #00FF00;
        --mork-magenta: #FF00FF;
        --mork-white: #FFFFFF;
        --mork-orange: #FF8000;
        --mork-gray: #808080;
    }

    body {
        background: var(--mork-black);
        color: var(--mork-white);
        font-family: monospace;
        margin: 0;
        padding: 0;
        overflow-x: hidden;
    }
    
    /* MÃ¶rk Borg Scrollbar Styling */
    ::-webkit-scrollbar {
        width: 12px;
        height: 12px;
    }
    
    ::-webkit-scrollbar-track {
        background: var(--mork-black);
        border: 1px solid var(--mork-cyan);
    }
    
    ::-webkit-scrollbar-thumb {
        background: var(--mork-cyan);
        border: 1px solid var(--mork-black);
        border-radius: 0;
    }
    
    ::-webkit-scrollbar-thumb:hover {
        background: var(--mork-yellow);
        box-shadow: 0 0 8px var(--mork-yellow);
    }
    
    ::-webkit-scrollbar-corner {
        background: var(--mork-black);
        border: 1px solid var(--mork-cyan);
    }
    
    /* Firefox scrollbar styling */
    * {
        scrollbar-width: thin;
        scrollbar-color: var(--mork-cyan) var(--mork-black);
    }
    
    h1, h2, h3, h4, h5, h6 {
        font-family: 'adhesive-nr-seven', serif;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    /* MÃ¶rk Borg Button Styling */
    .btn-mork-borg {
        background: var(--mork-black);
        border: 2px solid var(--mork-cyan);
        color: var(--mork-cyan);
        font-family: 'adhesive-nr-seven', serif;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: bold;
        padding: 8px 16px;
        margin: 2px;
        transition: all 0.3s ease;
        border-radius: 0;
        position: relative;
        overflow: hidden;
    }

    .btn-mork-borg:hover {
        background: var(--mork-cyan);
        color: var(--mork-black);
        box-shadow: 0 0 15px var(--mork-cyan);
        transform: translateY(-2px);
    }

    .btn-mork-borg:active {
        transform: translateY(0);
        box-shadow: 0 0 8px var(--mork-cyan);
    }

    .btn-mork-borg.btn-warning {
        border-color: var(--mork-yellow);
        color: var(--mork-yellow);
    }

    .btn-mork-borg.btn-warning:hover {
        background: var(--mork-yellow);
        color: var(--mork-black);
        box-shadow: 0 0 15px var(--mork-yellow);
    }

    .btn-mork-borg.btn-info {
        border-color: var(--mork-green);
        color: var(--mork-green);
    }

    .btn-mork-borg.btn-info:hover {
        background: var(--mork-green);
        color: var(--mork-black);
        box-shadow: 0 0 15px var(--mork-green);
    }

    .btn-mork-borg.btn-danger {
        border-color: var(--mork-magenta);
        color: var(--mork-magenta);
    }

    .btn-mork-borg.btn-danger:hover {
        background: var(--mork-magenta);
        color: var(--mork-black);
        box-shadow: 0 0 15px var(--mork-magenta);
    }

    /* Header Styling */
    .main-header {
        background: var(--mork-black);
        border-bottom: 3px solid var(--mork-cyan);
        padding: 20px 0;
        margin-bottom: 0;
        box-shadow: 0 4px 20px rgba(0, 255, 255, 0.3);
    }

    .main-header h1 {
        color: var(--mork-cyan);
        text-shadow: 0 0 10px var(--mork-cyan);
        margin: 0;
        font-size: 2.5rem;
    }

    /* Control Panel */
    .control-panel {
        background: var(--mork-black);
        border: 2px solid var(--mork-cyan);
        padding: 15px;
        margin-bottom: 0;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    /* Main Layout - Side by Side */
    .main-content {
        display: flex;
        height: calc(100vh - 200px);
        min-height: 600px;
    }

    .map-side {
        flex: 1;
        background: var(--mork-black);
        border-right: 2px solid var(--mork-cyan);
        padding: 20px;
        overflow: hidden;
        position: relative;
    }

    .modal-side {
        flex: 1;
        background: var(--mork-black);
        padding: 20px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
    }

    /* Map Container */
    .map-container {
        background: var(--mork-black);
        border: 2px solid var(--mork-cyan);
        border-radius: 0;
        padding: 15px;
        height: 100%;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }
    
    .hex-grid {
        font-family: 'Courier New', monospace;
        font-size: 0.9em;
        line-height: 1.1;
        overflow: auto;
        height: calc(100% - 40px);
        background: var(--mork-black);
        padding: 1em;
        border: 1px solid var(--mork-cyan);
        text-align: center;
        white-space: nowrap;
        /* Ensure proper scaling with browser zoom */
        transform-origin: top left;
        /* Consistent scrollbar styling */
        scrollbar-width: thin;
        scrollbar-color: var(--mork-cyan) var(--mork-black);
        /* Enable middle mouse drag scrolling */
        cursor: default;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    .hex-grid.dragging {
        cursor: grabbing;
    }
    
    .hex-grid.dragging .hex-cell {
        pointer-events: none;
    }
    
    .hex-cell {
        cursor: pointer;
        padding: 0.1em 0.2em;
        border-radius: 0.2em;
        transition: all 0.2s;
        display: inline-block;
        width: 1.2em;
        text-align: center;
        margin-right: 0;
        position: relative;
        font-size: 1em;
    }
    
    .hex-cell:hover {
        background-color: rgba(0, 255, 255, 0.3);
        transform: scale(1.3);
        z-index: 10;
        box-shadow: 0 0 8px var(--mork-cyan);
    }

    .hex-cell.selected {
        background-color: rgba(255, 255, 0, 0.4);
        box-shadow: 0 0 10px var(--mork-yellow);
        transform: scale(1.2);
        animation: blink 1s ease-in-out infinite;
    }
    
    @keyframes blink {
        0%, 50% {
            opacity: 1;
        }
        25%, 75% {
            opacity: 0.3;
        }
    }
    
    .major-city {
        color: var(--mork-yellow) !important;
        font-weight: bold;
        text-shadow: 0 0 5px var(--mork-yellow);
    }
    
    .settlement {
        color: var(--mork-green) !important;
        font-weight: bold;
        text-shadow: 0 0 5px var(--mork-green);
    }
    
    .terrain-mountain { color: var(--mork-magenta); }
    .terrain-forest { color: var(--mork-green); }
    .terrain-coast { color: var(--mork-cyan); }
    .terrain-plains { color: var(--mork-yellow); }
    .terrain-swamp { color: var(--mork-orange); }
    .terrain-unknown { color: var(--mork-gray); }
    
    .has-content {
        font-weight: bold;
        opacity: 1;
    }
    
    .no-content {
        opacity: 0.6;
    }
    
    /* Modal Side Content */
    .modal-content-container {
        background: var(--mork-black);
        border: 2px solid var(--mork-cyan);
        padding: 20px;
        height: 100%;
        overflow-y: auto;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
        /* Consistent scrollbar styling */
        scrollbar-width: thin;
        scrollbar-color: var(--mork-cyan) var(--mork-black);
    }

    .ascii-modal {
        font-family: 'Courier New', monospace;
        font-size: 0.9em;
        line-height: 1.3;
        color: var(--mork-cyan);
        background: var(--mork-black);
        border: 1px solid var(--mork-cyan);
        padding: 1em;
        margin: 0.8em 0;
        white-space: pre;
        /* Ensure proper scaling with browser zoom */
        transform-origin: top left;
    }

    /* Legend */
    .legend-integrated {
        font-size: 0.85em;
        color: var(--mork-cyan);
        padding: 5px 0;
    }
    
    .legend-integrated strong {
        color: var(--mork-white);
        font-size: 0.9em;
    }
    
    .map-row {
        display: block;
        text-align: left;
        margin: 0 auto;
        width: fit-content;
    }
    
    .row-number {
        display: inline-block;
        width: 2.5em;
        text-align: right;
        margin-right: 0.4em;
        color: var(--mork-cyan);
        font-size: 0.9em;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .main-content {
            flex-direction: column;
            height: auto;
        }

        .map-side, .modal-side {
            flex: none;
            width: 100%;
        }

        .map-side {
            border-right: none;
            border-bottom: 2px solid var(--mork-cyan);
            height: 400px;
        }

        .modal-side {
            height: 500px;
        }

        .main-header h1 {
            font-size: 2rem;
        }
    }

    @media (max-width: 576px) {
        .control-panel .btn-group {
            margin-bottom: 10px;
        }

        .legend-integrated {
            font-size: 0.75em;
        }
    }

    /* Loading States */
    .loading {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 200px;
        color: var(--mork-cyan);
        font-size: 1.2rem;
    }

    .loading::after {
        content: '';
        width: 20px;
        height: 20px;
        border: 2px solid var(--mork-cyan);
        border-top: 2px solid transparent;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-left: 10px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Empty State */
    .empty-state {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100%;
        color: var(--mork-gray);
        text-align: center;
    }

    .empty-state h4 {
        color: var(--mork-cyan);
        margin-bottom: 15px;
    }

    .empty-state p {
        font-size: 0.9rem;
        line-height: 1.5;
    }

    /* Vim-like Editing Interface */
    .vim-command-line {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--mork-black);
        border-top: 2px solid var(--mork-cyan);
        padding: 10px;
        font-family: 'Courier New', monospace;
        color: var(--mork-cyan);
        display: none;
        z-index: 1000;
    }

    .vim-command-line input {
        background: var(--mork-black);
        border: none;
        color: var(--mork-cyan);
        font-family: 'Courier New', monospace;
        font-size: 14px;
        width: 100%;
        outline: none;
    }

    .vim-command-line input::placeholder {
        color: var(--mork-gray);
    }

    .vim-mode-indicator {
        position: fixed;
        top: 10px;
        right: 10px;
        background: var(--mork-black);
        border: 1px solid var(--mork-cyan);
        padding: 5px 10px;
        font-family: 'Courier New', monospace;
        color: var(--mork-cyan);
        display: none;
        z-index: 1000;
    }

    .edit-mode {
        cursor: text;
    }

    .edit-mode .hex-content {
        border: 2px solid var(--mork-yellow);
        box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
    }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="main-header">
    <div class="container-fluid">
            <h1 class="text-center">THE DYING LANDS</h1>
        </div>
        </header>
        
        <!-- Control Panel -->
        <div class="control-panel">
        <div class="container-fluid">
            <div class="row">
                <div class="col-md-6">
                    <div class="btn-group me-2" role="group">
                        <button class="btn btn-mork-borg btn-warning" onclick="showTerrainOverview()">ğŸ—ºï¸ TERRAIN</button>
                        <button class="btn btn-mork-borg btn-info" onclick="showLoreOverview()">ğŸ“œ LORE</button>
                    </div>
                    <div class="btn-group" role="group">
                        <button class="btn btn-mork-borg btn-danger" onclick="resetContinent()">ğŸ”„ RESET CONTINENT</button>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="legend-integrated">
                        <div class="row">
                            <div class="col-md-6">
                                <strong>TERRAIN:</strong><br>
                                <span class="terrain-mountain">^</span> MOUNTAIN &nbsp;
                                <span class="terrain-forest">â™ </span> FOREST &nbsp;
                                <span class="terrain-coast">~</span> COAST<br>
                                <span class="terrain-plains">.</span> PLAINS &nbsp;
                                <span class="terrain-swamp">#</span> SWAMP
                </div>
                            <div class="col-md-6">
                                <strong>LOCATIONS:</strong><br>
                                <span class="major-city">â—†</span> MAJOR CITIES<br>
                                <span class="settlement">âŒ‚</span> SETTLEMENTS<br>
                                <strong>BOLD</strong> = HAS CONTENT
            </div>
        </div>
                            </div>
                        </div>
                </div>
            </div>
        </div>
        
    <!-- Main Content - Side by Side Layout -->
    <div class="main-content">
        <!-- Left Side - Map -->
        <div class="map-side">
        <div class="map-container">
            <div class="hex-grid" id="hexGrid">
                <!-- Map content will be loaded here -->
                {% if ascii_map %}
                    <!-- Column headers -->
                    <div class="text-center mb-2">
                        <span style="margin-right: 1.5em;"></span>
                        {% for x in range(1, map_width + 1) %}
                            <span style="margin-right: 0.3em; font-size: 0.8em; display: inline-block; width: 1em; text-align: center;">{{ '%02d' % x }}</span>
                        {% endfor %}
                    </div>
                        
                        <!-- Map rows -->
                        {% for y in range(1, map_height + 1) %}
                            <div class="map-row">
                                <span class="row-number">{{ '%02d' % y }}</span>
                                {% for x in range(1, map_width + 1) %}
                                    {% set hex_code = '%02d%02d' % (x, y) %}
                                    {% set hex_data = ascii_map[hex_code] %}
                                    {% if hex_data %}
                                        {% set css_class = hex_data.css_class %}
                                        {% set symbol = hex_data.symbol %}
                                        {% set has_content = 'has-content' if hex_data.has_content else 'no-content' %}
                                        {% set title = 'HEX ' + hex_code + ' - ' + hex_data.city_name if hex_data.is_city else 'HEX ' + hex_code %}
                                        <span class="hex-cell {{ css_class }} {{ has_content }}" 
                                              onclick="showHexDetails('{{ hex_code }}')" 
                                              data-hex="{{ hex_code }}"
                                              title="{{ title }}">{{ symbol }}</span>
                                    {% else %}
                                        <span class="hex-cell terrain-unknown no-content" 
                                              onclick="showHexDetails('{{ hex_code }}')" 
                                              data-hex="{{ hex_code }}"
                                              title="HEX {{ hex_code }}">?</span>
                                    {% endif %}
                                {% endfor %}
                            </div>
                        {% endfor %}
                    {% else %}
                        <div style="color: red; font-size: 20px;">MAP LOADING...</div>
                    {% endif %}
                </div>
            </div>
                </div>
                
        <!-- Right Side - Modal Content -->
        <div class="modal-side">
            <div class="modal-content-container" id="modalContainer">
                <div class="empty-state">
                    <h4>SELECT A HEX</h4>
                    <p>Click on any hex on the map to view its details, encounters, and lore.</p>
                    <div class="ascii-modal">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    THE DYING LANDS                           â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                              â•‘
â•‘  Click a hex to explore its mysteries...                    â•‘
â•‘                                                              â•‘
â•‘  Each hex contains unique encounters, denizens,             â•‘
â•‘  and secrets waiting to be discovered.                      â•‘
â•‘                                                              â•‘
â•‘  The world is dying, but adventure lives on.                â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                </div>
                </div>
            </div>
            </div>
        </div>
        
    <!-- Vim-like Editing Interface -->
    <div class="vim-command-line" id="vimCommandLine">
        <input type="text" id="vimCommandInput" placeholder=":" autocomplete="off">
    </div>
    
    <div class="vim-mode-indicator" id="vimModeIndicator">
        NORMAL
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Map data stored in data attributes to avoid linter issues -->
    <div id="mapData" 
         data-map="{{ ascii_map | tojson | safe if ascii_map else '{}' }}"
         data-width="{{ map_width|int if map_width else 0 }}"
         data-height="{{ map_height|int if map_height else 0 }}"
         style="display: none;">
    </div>

    <script>
        let currentHex = '';
        let isEditMode = false;
        let originalContent = '';
        
        // Map data from server - read from data attributes
        let mapData = {};
        let mapWidth = 0;
        let mapHeight = 0;
        

    
    // Define showHexDetails function first
    function showHexDetails(hexCode) {
        console.log('showHexDetails called with:', hexCode, 'isDragging:', isDragging);
        
        // Don't proceed if we're in a drag state
        if (isDragging) {
            console.log('Ignoring hex click due to drag state');
            return;
        }
        
        currentHex = hexCode;
        
        // Highlight selected hex on the map
        clearHexSelection();
        const hexElement = document.querySelector(`[data-hex="${hexCode}"]`);
        if (hexElement) {
            hexElement.classList.add('selected');
        }
        
        fetch(`/api/hex/${hexCode}`)
            .then(response => response.json())
            .then(data => {
                if (data.is_major_city) {
                    // Cities show in left panel (map area) with ASCII style
                    showCityDetailsInMap(hexCode);
                    return;
                }
                
                if (data.is_settlement) {
                    // Settlements show in left panel (map area) with ASCII style
                    showSettlementDetailsInMap(hexCode);
                    return;
                }
                
                // Regular hexes (encounters, dungeons, etc.) show in right panel
                displayHexContent(data, hexCode);
            })
            .catch(error => {
                console.error('Error fetching hex details:', error);
                // Show error in appropriate panel based on hex type
                if (currentHex && (currentHex.includes('city') || currentHex.includes('settlement'))) {
                    showMapErrorState(hexCode);
                } else {
                showErrorState(hexCode);
                }
            });
    }
    




    function clearHexSelection() {
        document.querySelectorAll('.hex-cell.selected').forEach(el => {
            el.classList.remove('selected');
        });
    }

    function showMapLoadingState() {
        const mapContainer = document.querySelector('.map-container');
        const originalContent = mapContainer.innerHTML;
        mapContainer.setAttribute('data-original-content', originalContent);
        
        mapContainer.innerHTML = `
            <div style="text-align: center; padding: 50px; color: var(--mork-cyan);">
                <pre style="font-family: 'Courier New', monospace; font-size: 14px;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    LOADING HEX DETAILS...                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                              â•‘
â•‘  Fetching encounters, denizens, and secrets...              â•‘
â•‘                                                              â•‘
â•‘  The dying lands reveal their mysteries slowly...           â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                </pre>
            </div>
        `;
    }

    function showMapErrorState(hexCode) {
        const mapContainer = document.querySelector('.map-container');
        mapContainer.innerHTML = `
            <div style="text-align: center; padding: 50px; color: var(--mork-magenta);">
                <pre style="font-family: 'Courier New', monospace; font-size: 14px;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ERROR LOADING HEX ${hexCode}                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                              â•‘
â•‘  Failed to load hex details.                                â•‘
â•‘  The darkness has consumed this knowledge...                â•‘
â•‘                                                              â•‘
â•‘  Please try again.                                          â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                </pre>
                <button class="btn btn-mork-borg btn-danger mt-3" onclick="restoreMap()">RETURN TO MAP</button>
            </div>
        `;
    }

    function showLoadingState() {
        const modalContainer = document.getElementById('modalContainer');
        modalContainer.innerHTML = `
            <div class="loading">
                Loading hex details...
            </div>
        `;
    }

    function showErrorState(hexCode) {
        const modalContainer = document.getElementById('modalContainer');
        modalContainer.innerHTML = `
            <div class="empty-state">
                <h4>ERROR LOADING HEX ${hexCode}</h4>
                <p>Failed to load hex details. Please try again.</p>
            </div>
        `;
    }

    function displayHexContent(data, hexCode) {
        const modalContainer = document.getElementById('modalContainer');
        
        let html = '';
        if (data.exists) {
            html = generateHexModalHTML(data, hexCode);
        } else {
            html = generateEmptyHexHTML(hexCode);
        }
        
        modalContainer.innerHTML = html;
    }

    function showCityDetailsInMap(hexCode) {
        // Disable drag functionality when showing city details
        disableDragFunctionality();
        
        // Show loading state in map area
        showMapLoadingState();
        
        fetch(`/api/city/${hexCode}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const city = data.city;
                    const mapContainer = document.querySelector('.map-container');
                    
                    let html = `
                        <div style="text-align: center; padding: 20px; height: 100%; overflow-y: auto;">
                            <button class="btn btn-mork-borg btn-warning mb-4" onclick="restoreMap()">RETURN TO MAP</button>
                            <div style="background: var(--mork-black); border: 2px solid var(--mork-cyan); padding: 20px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);">
                                <pre style="font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.2; color: var(--mork-cyan); margin: 0; white-space: pre-wrap; word-wrap: break-word;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ${city.name.toUpperCase().padEnd(50)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ LOCATION: HEX ${hexCode} - ${city.region.toUpperCase().padEnd(40)}â•‘
â•‘ POPULATION: ${city.population.padEnd(50)}â•‘
â•‘ ATMOSPHERE: ${city.atmosphere.substring(0, 50).padEnd(50)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ DESCRIPTION:                                                â•‘`;
                    
                    // Split description into lines
                    const descLines = city.description.match(/.{1,58}/g) || [city.description];
                    descLines.forEach(line => {
                        html += `
â•‘ ${line.padEnd(58)}â•‘`;
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ NOTABLE FEATURES:                                           â•‘`;
                    
                    city.notable_features.forEach(feature => {
                        const featureLines = feature.match(/.{1,56}/g) || [feature];
                        featureLines.forEach(line => {
                            html += `
â•‘ â€¢ ${line.padEnd(56)}â•‘`;
                        });
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ KEY NPCS:                                                   â•‘`;
                    
                    city.key_npcs.forEach(npc => {
                        const npcLines = npc.match(/.{1,56}/g) || [npc];
                        npcLines.forEach(line => {
                            html += `
â•‘ â€¢ ${line.padEnd(56)}â•‘`;
                        });
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ REGIONAL NPCS:                                              â•‘`;
                    
                    data.regional_npcs.forEach(npc => {
                        const npcLines = npc.match(/.{1,56}/g) || [npc];
                        npcLines.forEach(line => {
                            html += `
â•‘ â€¢ ${line.padEnd(56)}â•‘`;
                        });
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ACTIVE FACTIONS:                                            â•‘`;
                    
                    data.factions.forEach(faction => {
                        const factionText = `${faction.name} (${faction.influence}) - ${faction.description}`;
                        const factionLines = factionText.match(/.{1,56}/g) || [factionText];
                        factionLines.forEach(line => {
                            html += `
â•‘ â€¢ ${line.padEnd(56)}â•‘`;
                        });
                    });
                    
                    html += `
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                </pre>
                            </div>
            </div>
        `;
                    
                    mapContainer.innerHTML = html;
                    // Drag functionality is disabled for city details view
                } else {
                    showMapErrorState(hexCode);
                }
            })
            .catch(error => {
                console.error('ERROR LOADING CITY:', error);
                showMapErrorState(hexCode);
            });
    }

    function showSettlementDetailsInMap(hexCode) {
        // Disable drag functionality when showing settlement details
        disableDragFunctionality();
        
        // Show loading state in map area
        showMapLoadingState();
        
        fetch(`/api/settlement/${hexCode}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const settlement = data.settlement;
                    const mapContainer = document.querySelector('.map-container');
                    
                    let html = `
                        <div style="text-align: center; padding: 20px; height: 100%; overflow-y: auto;">
                            <button class="btn btn-mork-borg btn-warning mb-4" onclick="restoreMap()">RETURN TO MAP</button>
                            <div style="background: var(--mork-black); border: 2px solid var(--mork-cyan); padding: 20px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);">
                                <pre style="font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.2; color: var(--mork-cyan); margin: 0; white-space: pre-wrap; word-wrap: break-word;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ${settlement.name.toUpperCase().padEnd(50)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ LOCATION: HEX ${hexCode} - ${data.terrain.toUpperCase().padEnd(40)}â•‘
â•‘ POPULATION: ${settlement.population.padEnd(50)}â•‘
â•‘ ATMOSPHERE: ${settlement.atmosphere.substring(0, 50).padEnd(50)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ DESCRIPTION:                                                â•‘`;
                    
                    // Split description into lines
                    const descLines = settlement.description.match(/.{1,58}/g) || [settlement.description];
                    descLines.forEach(line => {
                        html += `
â•‘ ${line.padEnd(58)}â•‘`;
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ NOTABLE FEATURE:                                            â•‘`;
                    
                    const featureLines = settlement.notable_feature.match(/.{1,58}/g) || [settlement.notable_feature];
                    featureLines.forEach(line => {
                        html += `
â•‘ ${line.padEnd(58)}â•‘`;
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ LOCAL TAVERN:                                               â•‘`;
                    
                    const tavernLines = settlement.local_tavern.match(/.{1,58}/g) || [settlement.local_tavern];
                    tavernLines.forEach(line => {
                        html += `
â•‘ ${line.padEnd(58)}â•‘`;
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ LOCAL POWER:                                                â•‘`;
                    
                    const powerLines = settlement.local_power.match(/.{1,58}/g) || [settlement.local_power];
                    powerLines.forEach(line => {
                        html += `
â•‘ ${line.padEnd(58)}â•‘`;
                    });
                    
                    // Add settlement layout if present
                    if (data.settlement_layout && data.settlement_layout !== 'No settlement layout') {
                        html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ SETTLEMENT LAYOUT:                                          â•‘`;
                        const layoutLines = data.settlement_layout.split('\n');
                        layoutLines.forEach(line => {
                            html += `
â•‘ ${line.padEnd(58)}â•‘`;
                        });
                    }
                    

                    
                    html += `
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                </pre>
                            </div>
                        </div>
                    `;
                    
                    mapContainer.innerHTML = html;
                    // Drag functionality is disabled for settlement details view
                } else {
                    showMapErrorState(hexCode);
                }
            })
            .catch(error => {
                console.error('ERROR LOADING SETTLEMENT:', error);
                showMapErrorState(hexCode);
            });
    }



    function displayHexContent(data, hexCode) {
        const modalContainer = document.getElementById('modalContainer');
        
        let html = '';
        if (data.exists) {
            html = generateHexModalHTML(data, hexCode);
        } else {
            html = generateEmptyHexHTML(hexCode);
        }
        
        modalContainer.innerHTML = html;
    }

    function generateHexModalHTML(data, hexCode) {
        const terrain = data.terrain || 'unknown';
        const encounter = data.encounter || 'Unknown encounter';
        const denizen = data.denizen || 'No denizen information';
        const notableFeature = data.notable_feature || 'No notable features';
        const atmosphere = data.atmosphere || 'Unknown atmosphere';
        const treasure = data.treasure || 'No treasure found';
        const ancientKnowledge = data.ancient_knowledge || 'No ancient knowledge';
        const danger = data.danger || 'No dangers present';
        const threatLevel = data.threat_level || 'Unknown threat level';
        const territory = data.territory || 'No territory claimed';
        const location = data.location || 'Unknown location';
        const motivation = data.motivation || 'Unknown motivation';
        const demeanor = data.demeanor || 'Unknown demeanor';
        const feature = data.feature || 'No notable features';
        const settlementLayout = data.settlement_layout || '';
        
        // Generate ASCII terrain art
        const asciiTerrain = getAsciiTerrain(terrain);
        
        // Build the HTML string
        let html = `
            <div style="text-align: center; padding: 20px; height: 100%; overflow-y: auto;">
                <div style="background: var(--mork-black); border: 2px solid var(--mork-cyan); padding: 20px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);">
                    <pre style="font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.2; color: var(--mork-cyan); margin: 0; white-space: pre-wrap; word-wrap: break-word;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    HEX ${hexCode} - ${terrain.toUpperCase().padEnd(50)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ TERRAIN: ${terrain.charAt(0).toUpperCase() + terrain.slice(1).padEnd(50)}â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ TERRAIN ART:                                                â•‘`;
        
        // Add ASCII terrain art
        const terrainLines = asciiTerrain.split('\n');
        terrainLines.forEach(line => {
            html += `
â•‘ ${line.padEnd(58)}â•‘`;
        });
        
        html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ENCOUNTER:                                                  â•‘`;
        
        // Split encounter into lines
        const encounterLines = encounter.match(/.{1,58}/g) || [encounter];
        encounterLines.forEach(line => {
            html += `
â•‘ ${line.padEnd(58)}â•‘`;
        });
        
        html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ DENIZEN:                                                    â•‘`;
        
        // Split denizen into lines
        const denizenLines = denizen.match(/.{1,58}/g) || [denizen];
        denizenLines.forEach(line => {
            html += `
â•‘ ${line.padEnd(58)}â•‘`;
        });
        
        html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ NOTABLE FEATURES:                                           â•‘`;
        
        // Split notable features into lines
        const featureLines = notableFeature.match(/.{1,58}/g) || [notableFeature];
        featureLines.forEach(line => {
            html += `
â•‘ ${line.padEnd(58)}â•‘`;
        });
        
        html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ATMOSPHERE:                                                 â•‘`;
        
        // Split atmosphere into lines
        const atmosphereLines = atmosphere.match(/.{1,58}/g) || [atmosphere];
        atmosphereLines.forEach(line => {
            html += `
â•‘ ${line.padEnd(58)}â•‘`;
        });
        
        // Add treasure if present
        if (treasure && treasure !== 'No treasure found') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ TREASURE:                                                   â•‘`;
            const treasureLines = treasure.match(/.{1,58}/g) || [treasure];
            treasureLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add ancient knowledge if present
        if (ancientKnowledge && ancientKnowledge !== 'No ancient knowledge') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ ANCIENT KNOWLEDGE:                                          â•‘`;
            const knowledgeLines = ancientKnowledge.match(/.{1,58}/g) || [ancientKnowledge];
            knowledgeLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add danger if present
        if (danger && danger !== 'No dangers present') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ DANGER:                                                     â•‘`;
            const dangerLines = danger.match(/.{1,58}/g) || [danger];
            dangerLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add threat level if present
        if (threatLevel && threatLevel !== 'Unknown threat level') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ THREAT LEVEL:                                               â•‘`;
            const threatLines = threatLevel.match(/.{1,58}/g) || [threatLevel];
            threatLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add territory if present
        if (territory && territory !== 'No territory claimed') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ TERRITORY:                                                  â•‘`;
            const territoryLines = territory.match(/.{1,58}/g) || [territory];
            territoryLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add location if present
        if (location && location !== 'Unknown location') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ LOCATION:                                                   â•‘`;
            const locationLines = location.match(/.{1,58}/g) || [location];
            locationLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add motivation if present
        if (motivation && motivation !== 'Unknown motivation') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ MOTIVATION:                                                 â•‘`;
            const motivationLines = motivation.match(/.{1,58}/g) || [motivation];
            motivationLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add demeanor if present
        if (demeanor && demeanor !== 'Unknown demeanor') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ DEMEANOR:                                                   â•‘`;
            const demeanorLines = demeanor.match(/.{1,58}/g) || [demeanor];
            demeanorLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add feature if present
        if (feature && feature !== 'No notable features') {
            html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ FEATURE:                                                    â•‘`;
            const featureLines = feature.match(/.{1,58}/g) || [feature];
            featureLines.forEach(line => {
                html += `
â•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        // Add settlement layout if present
        if (settlementLayout && settlementLayout !== 'No settlement layout') {
            html += `\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘ SETTLEMENT LAYOUT:                                          â•‘`;
            const layoutLines = settlementLayout.split('\n');
            layoutLines.forEach(line => {
                html += `\nâ•‘ ${line.padEnd(58)}â•‘`;
            });
        }
        
        html += `
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    </pre>
                </div>
            </div>
        `;
        
        return html;
    }

    function generateEmptyHexHTML(hexCode) {
        return `
            <div style="text-align: center; padding: 20px; height: 100%; overflow-y: auto;">
                <div style="background: var(--mork-black); border: 2px solid var(--mork-cyan); padding: 20px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);">
                    <pre style="font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.2; color: var(--mork-cyan); margin: 0; white-space: pre-wrap; word-wrap: break-word;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    HEX ${hexCode} - EMPTY                    â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                              â•‘
â•‘  NO CONTENT GENERATED                                        â•‘
â•‘                                                              â•‘
â•‘  This hex has no content yet.                               â•‘
â•‘  Click "GENERATE CONTENT" to create encounters              â•‘
â•‘  and details for this location.                             â•‘
â•‘                                                              â•‘
â•‘  The dying lands await your exploration...                  â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    </pre>
                    <div class="text-center mt-4">
                        <button class="btn btn-mork-borg" onclick="generateHexContent('${hexCode}')">GENERATE CONTENT</button>
                    </div>
                            </div>
                        </div>
                    `;
    }

    function getAsciiTerrain(terrain) {
        const terrainArt = {
            'mountain': `    /\\   /\\   /\\
   /  \\_/  \\_/  \\
  /            \\
 /              \\`,
            'forest': `      /\\      /\\
     /  \\    /  \\
    /____\\  /____\\
      ||      ||`,
            'coast': `   ~   ~   ~   ~
 ~   ~   ~   ~
   ~   ~   ~   ~`,
            'plains': `  .  .  .  .  .
 .  .  .  .  .
  .  .  .  .  .`,
            'swamp': `  # # # # # #
 # # # # # # #
  # # # # # #`,
            'desert': `  ~~~~~~~~~~~
 ~~~~~.~~~~~
  ~~~~~~~~~~~`
        };
        
        return terrainArt[terrain] || terrainArt['plains'];
    }


    

    
    function restoreMap() {
        const mapContainer = document.querySelector('.map-container');
        const originalContent = mapContainer.getAttribute('data-original-content');
        if (originalContent) {
            mapContainer.innerHTML = originalContent;
            
            // Restore hex selection after returning to map
            if (currentHex) {
                const hexElement = document.querySelector(`[data-hex="${currentHex}"]`);
                if (hexElement) {
                    hexElement.classList.add('selected');
                }
            }
            
            // Ensure drag functionality is completely reset and re-initialized
            disableDragFunctionality();
            initMiddleMouseScroll();
            
            // Force re-attach all hex click events to ensure they work
            setTimeout(() => {
                const hexCells = document.querySelectorAll('.hex-cell');
                console.log('Re-attaching click events to', hexCells.length, 'hex cells');
                
                hexCells.forEach(hexCell => {
                    const hexCode = hexCell.getAttribute('data-hex');
                    if (hexCode) {
                        // Remove any existing click listeners to avoid duplicates
                        hexCell.onclick = null;
                        
                        // Add new click listener with drag check
                        hexCell.onclick = function(e) {
                            // Don't trigger hex details if we were just dragging
                            if (isDragging) {
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                            console.log('Hex clicked:', hexCode);
                            showHexDetails(hexCode);
                        };
                    }
                });
            }, 100); // Small delay to ensure DOM is ready
        } else {
            window.location.reload();
        }
    }
    
    function generateHexContent() {
        if (!currentHex) return;
        
        fetch('/api/generate-hex', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ hex: currentHex })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                showHexDetails(currentHex);
                setTimeout(() => window.location.reload(), 1000);
            } else {
                alert('FAILED TO GENERATE CONTENT: ' + data.error);
            }
        })
        .catch(error => {
            console.error('ERROR GENERATING HEX:', error);
            alert('ERROR GENERATING HEX CONTENT');
        });
    }
    
    function generateFullMap() {
        if (confirm('GENERATE CONTENT FOR THE ENTIRE MAP? THIS MAY TAKE A WHILE...')) {
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'â³ GENERATING...';
            btn.disabled = true;
            
            fetch('/api/generate-full-map', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`GENERATED ${data.count} HEXES!`);
                    window.location.reload();
                } else {
                    alert('FAILED TO GENERATE MAP: ' + data.error);
                }
            })
            .catch(error => {
                console.error('ERROR GENERATING MAP:', error);
                alert('ERROR GENERATING FULL MAP');
            })
            .finally(() => {
                btn.textContent = originalText;
                btn.disabled = false;
            });
        }
    }
    
    function resetContinent() {
        if (confirm('ğŸš¨ RESET ENTIRE CONTINENT? ğŸš¨\n\nTHIS WILL DELETE ALL GENERATED CONTENT AND CREATE A COMPLETELY FRESH MAP.\n\nTHIS ACTION CANNOT BE UNDONE!')) {
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'ğŸ”„ RESETTING...';
            btn.disabled = true;
            
            // Disable all other buttons during reset
            const allButtons = document.querySelectorAll('button');
            allButtons.forEach(button => button.disabled = true);
            
            fetch('/api/reset-continent', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert(`âœ… ${data.message}`);
                    window.location.reload();
                } else {
                    alert('âŒ FAILED TO RESET CONTINENT: ' + data.error);
                }
            })
            .catch(error => {
                console.error('ERROR RESETTING CONTINENT:', error);
                alert('âŒ ERROR RESETTING CONTINENT');
            })
            .finally(() => {
                // Re-enable all buttons
                allButtons.forEach(button => button.disabled = false);
                btn.textContent = originalText;
            });
        }
    }
    
    function showTerrainOverview() {
        // Show loading state in right panel
        showLoadingState();
        
        fetch('/api/terrain-overview')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const [width, height] = data.dimensions;
                    const modalContainer = document.getElementById('modalContainer');
                    
                    let html = `
                        <div style="text-align: center; padding: 20px; height: 100%; overflow-y: auto;">
                            <div style="background: var(--mork-black); border: 2px solid var(--mork-cyan); padding: 20px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);">
                                <pre style="font-family: 'Courier New', monospace; font-size: 10px; line-height: 1.2; color: var(--mork-cyan); margin: 0; white-space: pre-wrap; word-wrap: break-word;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ—ºï¸ TERRAIN OVERVIEW                       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                              â•‘
â•‘  TERRAIN MAP:                                                â•‘
â•‘                                                              â•‘`;
                    
                    // Add terrain map
                    const mapLines = data.terrain_map.split('\n');
                    mapLines.forEach(line => {
                        html += `
â•‘ ${line.padEnd(58)}â•‘`;
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ“Š TERRAIN STATISTICS:                                      â•‘
â•‘                                                              â•‘`;
                    
                    for (const key in data.distribution) {
                        if (!data.distribution.hasOwnProperty(key)) continue;
                        const terrain = String(key);
                        const count = data.distribution[key];
                        const percentage = ((count / (width * height)) * 100).toFixed(1);
                        const terrainSymbol = getTerrainSymbol(terrain);
                        const terrainName = terrain.charAt(0).toUpperCase() + terrain.slice(1);
                        const statLine = `${terrainSymbol} ${terrainName}: ${count} HEXES (${percentage}%)`;
                        const paddedLine = statLine.padEnd(58);
                        html += `
â•‘ ${paddedLine}â•‘`;
                    }
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ—ºï¸ MAP INFO:                                               â•‘
â•‘                                                              â•‘
â•‘  DIMENSIONS: ${width}Ã—${height}${' '.repeat(58 - (width + 'Ã—' + height).length)}â•‘
â•‘  TOTAL HEXES: ${width * height}${' '.repeat(58 - String(width * height).length)}â•‘
â•‘  LORE INTEGRATION: âœ… ACTIVE${' '.repeat(58 - 'LORE INTEGRATION: âœ… ACTIVE'.length)}â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                </pre>
                            </div>
                        </div>
                    `;
                    
                    modalContainer.innerHTML = html;
                } else {
                    showErrorState('terrain-overview');
                }
            })
            .catch(error => {
                console.error('ERROR LOADING TERRAIN OVERVIEW:', error);
                showErrorState('terrain-overview');
            });
    }
    
    function showLoreOverview() {
        // Show loading state in right panel
        showLoadingState();
        
        fetch('/api/lore-overview')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const modalContainer = document.getElementById('modalContainer');
                    
                    let html = `
                        <div style="text-align: center; padding: 20px; height: 100%; overflow-y: auto;">
                            <div style="background: var(--mork-black); border: 2px solid var(--mork-cyan); padding: 20px; box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);">
                                <pre style="font-family: 'Courier New', monospace; font-size: 10px; line-height: 1.2; color: var(--mork-cyan); margin: 0; white-space: pre-wrap; word-wrap: break-word;">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“œ MÃ–RK BORG LORE                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                              â•‘
â•‘  ğŸ° MAJOR CITIES (${data.major_cities}):                        â•‘
â•‘                                                              â•‘`;
                    
                    data.cities_data.forEach(city => {
                        const cityLine = `  ${city.name} (${city.hex_code}) - ${city.region}`;
                        const paddedLine = cityLine.padEnd(58);
                        html += `
â•‘ ${paddedLine}â•‘`;
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  âš”ï¸ MAJOR FACTIONS (${data.factions}):                         â•‘
â•‘                                                              â•‘`;
                    
                    data.factions_data.forEach(faction => {
                        const factionLine = `  ${faction.name} (${faction.influence})`;
                        const paddedLine = factionLine.padEnd(58);
                        html += `
â•‘ ${paddedLine}â•‘`;
                        
                        const regionsLine = `    Active in: ${faction.regions.join(', ')}`;
                        const paddedRegionsLine = regionsLine.padEnd(58);
                        html += `
â•‘ ${paddedRegionsLine}â•‘`;
                    });
                    
                    html += `
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ² GAME MASTER NOTE:                                        â•‘
â•‘                                                              â•‘
â•‘  LORE INTEGRATION: THIS LORE IS INTEGRATED INTO              â•‘
â•‘  HEX GENERATION. CITIES AND FACTIONS INFLUENCE              â•‘
â•‘  CONTENT IN THEIR REGIONS.                                   â•‘
â•‘                                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                </pre>
                            </div>
                        </div>
                    `;
                    
                    modalContainer.innerHTML = html;
                } else {
                    showErrorState('lore-overview');
                }
            })
            .catch(error => {
                console.error('ERROR LOADING LORE OVERVIEW:', error);
                showErrorState('lore-overview');
            });
    }
    
    function getTerrainSymbol(terrain) {
        const symbols = {
            'mountain': '^', 'forest': 'â™ ', 'coast': '~',
            'plains': '.', 'swamp': '#', 'unknown': '?'
        };
        return symbols[terrain] || '?';
    }

    // Vim-like Editing System
    function initVimEditing() {
        const commandLine = document.getElementById('vimCommandLine');
        const commandInput = document.getElementById('vimCommandInput');
        const modeIndicator = document.getElementById('vimModeIndicator');

        // Global keyboard event listener
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'INPUT') return; // Don't interfere with input fields
            
            // Browser zoom shortcuts - let browser handle zoom naturally
            if (e.ctrlKey || e.metaKey) {
                if (e.key === '=' || e.key === '+' || e.key === '-') {
                    // Don't prevent default - let browser handle zoom
                    return;
                }
            }
            
            if (isEditMode) {
                handleEditModeKey(e);
            } else {
                handleNormalModeKey(e);
            }
        });

        // Command input handling
        commandInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                const command = commandInput.value.trim();
                processVimCommand(command);
                commandInput.value = '';
                hideCommandLine();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                commandInput.value = '';
                hideCommandLine();
            }
        });
    }

    function handleNormalModeKey(e) {
        if (e.key === 'i' && currentHex) {
            e.preventDefault();
            e.stopPropagation();
            enterInsertMode();
        } else if (e.key === ':') {
            e.preventDefault();
            e.stopPropagation();
            showCommandLine();
        }
    }

    function handleEditModeKey(e) {
        if (e.key === 'Escape') {
            e.preventDefault();
            e.stopPropagation();
            exitInsertMode();
        }
    }

    function enterInsertMode() {
        isEditMode = true;
        document.body.classList.add('edit-mode');
        showModeIndicator('INSERT');
        
        // Store original content
        const modalContainer = document.getElementById('modalContainer');
        if (modalContainer) {
            originalContent = modalContainer.innerHTML;
            makeContentEditable(modalContainer);
        }
    }

    function exitInsertMode() {
        isEditMode = false;
        document.body.classList.remove('edit-mode');
        showModeIndicator('NORMAL');
        
        // Make content non-editable
        const modalContainer = document.getElementById('modalContainer');
        if (modalContainer) {
            makeContentNonEditable(modalContainer);
        }
    }

    function makeContentEditable(container) {
        const preElements = container.querySelectorAll('pre');
        console.log('Making pre elements editable:', preElements.length);
        preElements.forEach((pre, index) => {
            pre.contentEditable = true;
            pre.style.outline = '2px solid var(--mork-yellow)';
            pre.style.padding = '5px';
            console.log(`Made pre element ${index} editable`);
        });
        
        // Focus on the first pre element
        if (preElements.length > 0) {
            preElements[0].focus();
        }
    }

    function makeContentNonEditable(container) {
        const preElements = container.querySelectorAll('pre');
        console.log('Making pre elements non-editable:', preElements.length);
        preElements.forEach((pre, index) => {
            pre.contentEditable = false;
            pre.style.outline = 'none';
            pre.style.padding = '';
            console.log(`Made pre element ${index} non-editable`);
        });
    }

    function showCommandLine() {
        const commandLine = document.getElementById('vimCommandLine');
        const commandInput = document.getElementById('vimCommandInput');
        commandLine.style.display = 'block';
        commandInput.focus();
    }

    function hideCommandLine() {
        const commandLine = document.getElementById('vimCommandLine');
        const commandInput = document.getElementById('vimCommandInput');
        commandLine.style.display = 'none';
        commandInput.value = '';
        commandInput.blur();
    }

    function showModeIndicator(mode) {
        const indicator = document.getElementById('vimModeIndicator');
        indicator.textContent = mode;
        indicator.style.display = 'block';
        
        // Hide after 2 seconds
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 2000);
    }

    function processVimCommand(command) {
        switch (command) {
            case 'wq':
                saveAndQuit();
                break;
            case 'q':
                quitWithoutSaving();
                break;
            case 'w':
                saveContent();
                break;
            default:
                if (command.startsWith('s/')) {
                    // Simple search and replace
                    const parts = command.split('/');
                    if (parts.length >= 3) {
                        const search = parts[1];
                        const replace = parts[2];
                        searchAndReplace(search, replace);
                    }
                } else {
                    showVimMessage(`Unknown command: ${command}`);
                }
        }
    }

    function saveAndQuit() {
        saveContent();
        exitInsertMode();
        showVimMessage('Content saved and quit');
        // Clear any potential input
        document.activeElement.blur();
    }

    function quitWithoutSaving() {
        // Restore original content
        const modalContainer = document.getElementById('modalContainer');
        if (modalContainer && originalContent) {
            modalContainer.innerHTML = originalContent;
        }
        exitInsertMode();
        showVimMessage('Quit without saving');
        // Clear any potential input
        document.activeElement.blur();
    }

    function saveContent() {
        const modalContainer = document.getElementById('modalContainer');
        if (!modalContainer || !currentHex) {
            console.log('Save failed: No container or hex selected', { modalContainer: !!modalContainer, currentHex });
            showVimMessage('No content to save');
            return;
        }

        // Extract the edited content from the pre elements
        const preElements = modalContainer.querySelectorAll('pre');
        console.log('Found pre elements:', preElements.length);
        
        let editedContent = '';
        preElements.forEach((pre, index) => {
            // Get the text content and preserve line breaks
            const content = pre.textContent || pre.innerText;
            console.log(`Pre element ${index} content:`, content.substring(0, 100) + '...');
            editedContent += content + '\n';
        });

        // Clean up the content - remove any extra whitespace
        editedContent = editedContent.trim();
        console.log('Final edited content length:', editedContent.length);

        if (!editedContent) {
            console.log('Save failed: No content extracted');
            showVimMessage('No content to save');
            return;
        }

        // Show saving indicator
        showVimMessage('Saving...');
        console.log('Sending save request for hex:', currentHex);

        // Send the edited content to the server
        fetch(`/api/save-hex/${currentHex}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                hex_code: currentHex,
                content: editedContent
            })
        })
        .then(response => {
            console.log('Save response status:', response.status);
            return response.json();
        })
        .then(data => {
            console.log('Save response data:', data);
            if (data.success) {
                showVimMessage('Content saved successfully');
                // Refresh the hex content to show the updated version
                showHexDetails(currentHex);
            } else {
                showVimMessage(`Save failed: ${data.error}`);
            }
        })
        .catch(error => {
            console.error('Error saving content:', error);
            showVimMessage('Save failed: Network error');
        });
    }

    function searchAndReplace(search, replace) {
        const modalContainer = document.getElementById('modalContainer');
        if (modalContainer) {
            const content = modalContainer.innerHTML;
            const newContent = content.replace(new RegExp(search, 'g'), replace);
            modalContainer.innerHTML = newContent;
            showVimMessage(`Replaced '${search}' with '${replace}'`);
        }
    }

    function showVimMessage(message) {
        const indicator = document.getElementById('vimModeIndicator');
        indicator.textContent = message;
        indicator.style.display = 'block';
        
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 2000);
    }

    // Debug function - can be called from browser console
    function testSave() {
        console.log('Testing save functionality...');
        console.log('Current hex:', currentHex);
        console.log('Is edit mode:', isEditMode);
        
        const modalContainer = document.getElementById('modalContainer');
        console.log('Modal container:', modalContainer);
        
        if (modalContainer) {
            const preElements = modalContainer.querySelectorAll('pre');
            console.log('Pre elements found:', preElements.length);
            preElements.forEach((pre, index) => {
                console.log(`Pre ${index}:`, pre.textContent.substring(0, 50));
            });
        }
        
        // Try to save
        saveContent();
    }

    // Initialize vim editing when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        const mapDataElement = document.getElementById('mapData');
        if (mapDataElement) {
            try {
                const mapDataString = mapDataElement.dataset.map || '{}';
                console.log('Raw map data string length:', mapDataString.length);
                
                // Check if the string is valid JSON
                if (mapDataString.trim() === '') {
                    console.warn('Empty map data, using empty object');
                    mapData = {};
                } else {
                    mapData = JSON.parse(mapDataString);
                    console.log('Map data loaded successfully:', Object.keys(mapData).length, 'hexes');
                }
                
                mapWidth = parseInt(mapDataElement.dataset.width || '0');
                mapHeight = parseInt(mapDataElement.dataset.height || '0');
            } catch (error) {
                console.error('Error loading map data:', error);
                console.error('Map data string preview:', mapDataElement.dataset.map?.substring(0, 200));
                // Use empty data as fallback
                mapData = {};
                mapWidth = 0;
                mapHeight = 0;
            }
        }
        
        // Initialize vim editing system
        initVimEditing();
        
        // Initialize middle mouse scroll functionality
        initMiddleMouseScroll();
        
        // Clean up event listeners when page is unloaded
        window.addEventListener('beforeunload', function() {
            cleanupDragEventListeners();
        });
    });
    
    // Middle mouse drag scrolling functionality - simplified approach
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let scrollStartX = 0;
    let scrollStartY = 0;
    let dragEnabled = false; // Global flag to control drag functionality
    
    function initMiddleMouseScroll() {
        const hexGrid = document.getElementById('hexGrid');
        if (!hexGrid) return;
        
        // Reset drag state
        isDragging = false;
        hexGrid.classList.remove('dragging');
        hexGrid.style.cursor = 'default';
        
        // Clear any existing event handlers
        hexGrid.onmousedown = null;
        hexGrid.oncontextmenu = null;
        hexGrid.onmouseleave = null;
        document.onmousemove = null;
        document.onmouseup = null;
        
        // Enable drag functionality
        dragEnabled = true;
        
        // Simple event handlers - no complex cleanup needed
        hexGrid.onmousedown = function(e) {
            if (!dragEnabled) return; // Don't do anything if drag is disabled
            
            if (e.button === 1) { // Middle mouse button
                e.preventDefault();
                e.stopPropagation();
                
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                scrollStartX = hexGrid.scrollLeft;
                scrollStartY = hexGrid.scrollTop;
                
                hexGrid.classList.add('dragging');
                hexGrid.style.cursor = 'grabbing';
            }
        };
        
        // Use onmouseover/onmouseout instead of addEventListener to avoid conflicts
        document.onmousemove = function(e) {
            if (!dragEnabled || !isDragging) return;
            
            const deltaX = dragStartX - e.clientX;
            const deltaY = dragStartY - e.clientY;
            
            hexGrid.scrollLeft = scrollStartX + deltaX;
            hexGrid.scrollTop = scrollStartY + deltaY;
        };
        
        document.onmouseup = function(e) {
            if (!dragEnabled) return;
            
            if (isDragging) {
                isDragging = false;
                hexGrid.classList.remove('dragging');
                hexGrid.style.cursor = 'default';
                
                // Prevent any click events from firing after drag
                e.preventDefault();
                e.stopPropagation();
                
                // Clear any potential hex selection that might have been triggered during drag
                clearHexSelection();
            }
        };
        
        hexGrid.oncontextmenu = function(e) {
            if (!dragEnabled) return;
            
            if (e.button === 1) {
                e.preventDefault();
            }
        };
        
        hexGrid.onmouseleave = function(e) {
            if (!dragEnabled) return;
            
            if (isDragging) {
                isDragging = false;
                hexGrid.classList.remove('dragging');
                hexGrid.style.cursor = 'default';
            }
        };
    }
    
    function cleanupDragEventListeners() {
        // Reset all drag state variables
        dragEnabled = false;
        isDragging = false;
        dragStartX = 0;
        dragStartY = 0;
        scrollStartX = 0;
        scrollStartY = 0;
        
        const hexGrid = document.getElementById('hexGrid');
        if (hexGrid) {
            hexGrid.classList.remove('dragging');
            hexGrid.style.cursor = 'default';
        }
    }
    
    function disableDragFunctionality() {
        // Completely disable drag functionality
        dragEnabled = false;
        isDragging = false;
        dragStartX = 0;
        dragStartY = 0;
        scrollStartX = 0;
        scrollStartY = 0;
        
        const hexGrid = document.getElementById('hexGrid');
        if (hexGrid) {
            hexGrid.classList.remove('dragging');
            hexGrid.style.cursor = 'default';
            
            // Clear all event handlers
            hexGrid.onmousedown = null;
            hexGrid.oncontextmenu = null;
            hexGrid.onmouseleave = null;
        }
        
        // Clear document event handlers
        document.onmousemove = null;
        document.onmouseup = null;
    }
    
    // Global function to force reset drag state (can be called from console for debugging)
    function forceResetDragState() {
        console.log('Force resetting drag state');
        dragEnabled = false;
        isDragging = false;
        dragStartX = 0;
        dragStartY = 0;
        scrollStartX = 0;
        scrollStartY = 0;
        
        const hexGrid = document.getElementById('hexGrid');
        if (hexGrid) {
            hexGrid.classList.remove('dragging');
            hexGrid.style.cursor = 'default';
        }
        
        // Also clear any hex selections that might be stuck
        clearHexSelection();
    }
    
    // Global function to test hex click events (can be called from console for debugging)
    function testHexClicks() {
        console.log('Testing hex click events...');
        const hexCells = document.querySelectorAll('.hex-cell');
        console.log('Found', hexCells.length, 'hex cells');
        
        hexCells.forEach((hexCell, index) => {
            const hexCode = hexCell.getAttribute('data-hex');
            const hasOnclick = hexCell.onclick !== null;
            console.log(`Hex ${index}: ${hexCode}, has onclick: ${hasOnclick}`);
        });
    }
    
    </script>
</body>
</html>